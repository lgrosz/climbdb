BEGIN;
SELECT plan(24);

SELECT has_table('climb_super_area_closures');
SELECT has_table('climb_super_formation_closures');

SELECT has_column('climb_super_area_closures', 'climb_id');
SELECT col_is_pk('climb_super_area_closures', 'climb_id');
SELECT col_is_fk('climb_super_area_closures', 'climb_id');
SELECT has_column('climb_super_area_closures', 'super_area_id');
SELECT col_is_fk('climb_super_area_closures', 'super_area_id');

SELECT has_column('climb_super_formation_closures', 'climb_id');
SELECT col_is_pk('climb_super_formation_closures', 'climb_id');
SELECT col_is_fk('climb_super_formation_closures', 'climb_id');
SELECT has_column('climb_super_formation_closures', 'super_formation_id');
SELECT col_is_fk('climb_super_formation_closures', 'super_formation_id');

CREATE FUNCTION test_climb_area_cascade_on_delete()
RETURNS SETOF TEXT
AS $$
DECLARE
    climb_a climbs%ROWTYPE;
    area_b areas%ROWTYPE;
BEGIN
    INSERT INTO climbs DEFAULT VALUES RETURNING * INTO climb_a;
    INSERT INTO areas DEFAULT VALUES RETURNING * INTO area_b;

    INSERT INTO climb_super_area_closures (climb_id, super_area_id)
    VALUES (climb_a.id, area_b.id);

    RETURN NEXT isnt_empty(
        format('SELECT * FROM climb_super_area_closures WHERE climb_id = %s', climb_a.id),
        'Climb super area closure exists before cascade deletion'
    );

    DELETE FROM climbs WHERE id = climb_a.id;

    RETURN NEXT is_empty(
        format('SELECT * FROM climb_super_area_closures WHERE climb_id = %s', climb_a.id),
        'Climb super area closure does not exist after cascade deletion'
    );
END;
$$ LANGUAGE plpgsql;

SELECT * FROM test_climb_area_cascade_on_delete();

CREATE FUNCTION test_climb_formation_cascade_on_delete()
RETURNS SETOF TEXT
AS $$
DECLARE
    climb_a climbs%ROWTYPE;
    formation_b formations%ROWTYPE;
BEGIN
    INSERT INTO climbs DEFAULT VALUES RETURNING * INTO climb_a;
    INSERT INTO formations DEFAULT VALUES RETURNING * INTO formation_b;

    INSERT INTO climb_super_formation_closures (climb_id, super_formation_id)
    VALUES (climb_a.id, formation_b.id);

    RETURN NEXT isnt_empty(
        format('SELECT * FROM climb_super_formation_closures WHERE climb_id = %s', climb_a.id),
        'Climb super formation closure exists before cascade deletion'
    );

    DELETE FROM climbs WHERE id = climb_a.id;

    RETURN NEXT is_empty(
        format('SELECT * FROM climb_super_formation_closures WHERE climb_id = %s', climb_a.id),
        'Climb super formation closure does not exist after cascade deletion'
    );
END;
$$ LANGUAGE plpgsql;

SELECT * FROM test_climb_formation_cascade_on_delete();

CREATE FUNCTION test_super_area_id_restrict_on_delete()
RETURNS SETOF TEXT
AS $$
DECLARE
    climb_a climbs%ROWTYPE;
    area_b areas%ROWTYPE;
BEGIN
    INSERT INTO climbs DEFAULT VALUES RETURNING * INTO climb_a;
    INSERT INTO areas DEFAULT VALUES RETURNING * INTO area_b;

    INSERT INTO climb_super_area_closures (climb_id, super_area_id)
    VALUES (climb_a.id, area_b.id);

    RETURN NEXT isnt_empty(
        format('SELECT * FROM climb_super_area_closures WHERE climb_id = %s', climb_a.id),
        'Climb super area closure exists before restrict deletion'
    );

    PREPARE delete_area AS DELETE FROM areas WHERE id = $1;

    RETURN NEXT throws_ok(
        format('EXECUTE delete_area(%s)', area_b.id),
        '23503',
        'update or delete on table "areas" violates foreign key constraint "climb_super_area_closures_super_area_id_fkey" on table "climb_super_area_closures"',
        'Restrict super-area deletion when closure present'
    );
END;
$$ LANGUAGE plpgsql;

SELECT * FROM test_super_area_id_restrict_on_delete();

CREATE FUNCTION test_super_formation_id_restrict_on_delete()
RETURNS SETOF TEXT
AS $$
DECLARE
    climb_a climbs%ROWTYPE;
    formation_b formations%ROWTYPE;
BEGIN
    INSERT INTO climbs DEFAULT VALUES RETURNING * INTO climb_a;
    INSERT INTO formations DEFAULT VALUES RETURNING * INTO formation_b;

    INSERT INTO climb_super_formation_closures (climb_id, super_formation_id)
    VALUES (climb_a.id, formation_b.id);

    RETURN NEXT isnt_empty(
        format('SELECT * FROM climb_super_formation_closures WHERE climb_id = %s', climb_a.id),
        'Climb super formation closure exists before restrict deletion'
    );

    PREPARE delete_formation AS DELETE FROM formations WHERE id = $1;

    RETURN NEXT throws_ok(
        format('EXECUTE delete_formation(%s)', formation_b.id),
        '23503',
        'update or delete on table "formations" violates foreign key constraint "climb_super_formation_closures_super_formation_id_fkey" on table "climb_super_formation_closures"',
        'Restrict super-formation deletion when closure present'
    );
END;
$$ LANGUAGE plpgsql;

SELECT * FROM test_super_formation_id_restrict_on_delete();

CREATE FUNCTION test_area_to_formation_closure()
RETURNS SETOF TEXT
AS $$
DECLARE
    climb_a climbs%ROWTYPE;
    area_b areas%ROWTYPE;
    formation_c formations%ROWTYPE;
BEGIN
    INSERT INTO climbs DEFAULT VALUES RETURNING * INTO climb_a;
    INSERT INTO areas DEFAULT VALUES RETURNING * INTO area_b;
    INSERT INTO formations DEFAULT VALUES RETURNING * INTO formation_c;

    RETURN NEXT lives_ok(
        format('INSERT INTO climb_super_area_closures (climb_id, super_area_id) VALUES (%s, %s)', climb_a.id, area_b.id),
        'No exception should occur when inserting into climb_super_area_closures'
    );

    RETURN NEXT throws_ok(
        format('INSERT INTO climb_super_formation_closures (climb_id, super_formation_id) VALUES (%s, %s)', climb_a.id, formation_c.id),
        'P0001',
        'super area closure exists',
        'Mutual exclusivity enforced between super_area and super_formation'
    );
END;
$$ LANGUAGE plpgsql;

SELECT * FROM test_area_to_formation_closure();

CREATE FUNCTION test_formation_to_area_closure()
RETURNS SETOF TEXT
AS $$
DECLARE
    climb_a climbs%ROWTYPE;
    formation_b formations%ROWTYPE;
    area_c areas%ROWTYPE;
BEGIN
    INSERT INTO climbs DEFAULT VALUES RETURNING * INTO climb_a;
    INSERT INTO formations DEFAULT VALUES RETURNING * INTO formation_b;
    INSERT INTO areas DEFAULT VALUES RETURNING * INTO area_c;

    RETURN NEXT lives_ok(
        format('INSERT INTO climb_super_formation_closures (climb_id, super_formation_id) VALUES (%s, %s)', climb_a.id, formation_b.id),
        'No exception should occur when inserting into climb_super_formation_closures'
    );

    RETURN NEXT throws_ok(
        format('INSERT INTO climb_super_area_closures (climb_id, super_area_id) VALUES (%s, %s)', climb_a.id, area_c.id),
        'P0001',
        'super formation closure exists',
        'Mutual exclusivity enforced between super_formation and super_area'
    );
END;
$$ LANGUAGE plpgsql;

SELECT * FROM test_formation_to_area_closure();

SELECT * FROM finish();
ROLLBACK;
